{
  "version": 3,
  "sources": [
    "C:/Users/klein/AppData/Roaming/npm/node_modules/@qooxdoo/framework/source/class/qx/tool/utils/json/Stringify.js"
  ],
  "names": [
    "qx",
    "Bootstrap",
    "executePendingDefers",
    "$$dbClassInfo",
    "Class",
    "define",
    "extend",
    "core",
    "Object",
    "statics",
    "prettyPrint",
    "ast",
    "writer",
    "tool",
    "utils",
    "json",
    "Writer",
    "writeNode",
    "node",
    "type",
    "comments",
    "leadingComments",
    "write",
    "indent",
    "children",
    "forEach",
    "child",
    "index",
    "key",
    "value",
    "length",
    "trailingComments",
    "rawValue",
    "Error",
    "buffer",
    "reprint",
    "object",
    "prettyPojo",
    "tokenizer",
    "obj",
    "lang",
    "Type",
    "isArray",
    "elem",
    "first",
    "oldIndent",
    "matchIndent",
    "name",
    "resetIndent",
    "prettyPojoProperty",
    "startTokenIndex",
    "writeTokensUntil",
    "token",
    "tokens",
    "pretty",
    "str",
    "Stringify",
    "maxEndToken",
    "endToken",
    "undefined",
    "startToken",
    "isPlainObject",
    "childAstLookup",
    "childPropertyLookup",
    "i",
    "Tokenizer",
    "tokenTypes",
    "COMMA",
    "isLiteral",
    "isSameLiteral",
    "COMMENT",
    "WHITESPACE",
    "astToObject",
    "settings",
    "result",
    "push",
    "proto",
    "getPrototypeOf",
    "prototype"
  ],
  "mappings": "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",
  "sourcesContent": [
    "/* ************************************************************************\n *\n *    qooxdoo-compiler - node.js based replacement for the Qooxdoo python\n *    toolchain\n *\n *    https://github.com/qooxdoo/qooxdoo\n *\n *    Copyright:\n *      2011-2019 Zenesis Limited, http://www.zenesis.com\n *\n *    License:\n *      MIT: https://opensource.org/licenses/MIT\n *\n *      This software is provided under the same licensing terms as Qooxdoo,\n *      please see the LICENSE file in the Qooxdoo project's top-level directory\n *      for details.\n *\n *    Authors:\n *      * John Spackman (john.spackman@zenesis.com, @johnspackman)\n *\n * *********************************************************************** */\n\n/* eslint-disable no-redeclare */\n\n/**\n * Stringify\n */\nqx.Class.define(\"qx.tool.utils.json.Stringify\", {\n  extend: qx.core.Object,\n\n  statics: {\n    /**\n     * Pretty prints an AST tree\n     */\n    prettyPrint(ast) {\n      var writer = new qx.tool.utils.json.Writer();\n\n      /**\n       * Writes a node, used recursively\n       */\n      function writeNode(node) {\n        switch (node.type) {\n          case \"object\":\n            writer.comments(node.leadingComments);\n            writer.write(\"{\\n\").indent(+1);\n            node.children.forEach(function (child, index) {\n              if (index > 0) {\n                writer.write(\",\\n\");\n              }\n              writer.write('\"' + child.key.value + '\" : ');\n              writeNode(child.value);\n            });\n            if (node.children.length) {\n              writer.write(\"\\n\");\n            }\n            writer.comments(node.trailingComments);\n            writer.indent(-1).write(\"}\");\n            break;\n\n          case \"array\":\n            writer.comments(node.leadingComments);\n            writer.write(\"[\\n\").indent(+1);\n            node.children.forEach(function (child, index) {\n              if (index > 0) {\n                writer.write(\",\\n\");\n              }\n              writeNode(child.value);\n            });\n            if (node.children.length) {\n              writer.write(\"\\n\");\n            }\n            writer.comments(node.trailingComments);\n            writer.indent(-1).write(\"]\\n\");\n            break;\n\n          case \"property\":\n            writeNode(node.key);\n            writer.write(\" : \");\n            writeNode(node.value);\n            break;\n\n          case \"identifier\":\n            writer.write('\"' + node.value + '\"');\n            break;\n\n          case \"literal\":\n            writer.comments(node.leadingComments);\n            writer.write(node.rawValue);\n            writer.comments(node.trailingComments);\n            break;\n\n          default:\n            throw new Error(\"Unexpected node type '\" + node.type + \"'\");\n        }\n      }\n\n      writeNode(ast);\n\n      return writer.buffer;\n    },\n\n    /**\n     * Prints an object out, using the AST to preserve formatting and whitespace\n     * (and include comments) wherever possible.  Any parts of the object which\n     * do not have a corresponding AST tree will be pretty printed\n     *\n     * This is only really suitable for amendments to the object graph because\n     * preserving formatting & comments relies on a 1:1 comparison between the\n     * AST and the object.  This means that if you move a subset of an object to\n     * another part of the object graph, it will be seen as a deletion of one\n     * subset and a brand new subset - you will loose all comments as well as\n     * layout.\n     *\n     * @param object {Object}\n     * @param ast {Tokenizer}\n     * @return {String}\n     */\n    reprint(object, ast) {\n      var writer = new qx.tool.utils.json.Writer();\n\n      if (!ast) {\n        prettyPojo(object);\n        return writer.buffer;\n      }\n      var tokenizer = ast.tokenizer;\n\n      /*\n       * Pretty prints any old POJO or native value\n       */\n      function prettyPojo(obj) {\n        if (typeof obj == \"string\") {\n          writer.write('\"' + obj + '\"');\n        } else if (typeof obj == \"number\") {\n          writer.write(obj);\n        } else if (typeof obj == \"boolean\") {\n          writer.write(obj ? \"true\" : \"false\");\n        } else if (qx.lang.Type.isArray(obj)) {\n          writer.write(\"[ \");\n          obj.forEach(function (elem, index) {\n            if (index != 0) {\n              writer.write(\", \");\n            }\n            prettyPojo(elem);\n          });\n          writer.write(\" ]\");\n        } else {\n          var first = true;\n          var oldIndent = writer.matchIndent();\n          writer.write(\"{\\n\").indent(+1);\n          for (var name in obj) {\n            if (!first) {\n              writer.write(\",\\n\");\n            }\n            writer.write('\"' + name + '\": ');\n            prettyPojo(obj[name]);\n            first = false;\n          }\n          writer.write(\"\\n\").indent(-1).write(\"}\");\n          writer.resetIndent(oldIndent);\n        }\n      }\n\n      /*\n       * Pretty prints a key:value pair\n       */\n      function prettyPojoProperty(key, value) {\n        writer.write('\"' + key + '\": ');\n        prettyPojo(value);\n      }\n\n      /*\n       * Writes tokens which underly the AST, up to a given index\n       */\n      var startTokenIndex = 0;\n      function writeTokensUntil(index) {\n        if (startTokenIndex > -1) {\n          while (startTokenIndex < index) {\n            var token = tokenizer.tokens[startTokenIndex];\n            writer.write(token.rawValue || token.value);\n            startTokenIndex++;\n          }\n        }\n      }\n\n      /*\n       * Writes an object, comparing it with the AST node.  Used recursively\n       */\n      function writeNode(object, node) {\n        /*\n         * Pretty prints a node to the writer\n         */\n        function pretty(node) {\n          var str = qx.tool.utils.json.Stringify.prettyPrint(node);\n          writer.write(str);\n          startTokenIndex = -1;\n        }\n\n        /*\n         * Calculates the largest endToken\n         *\n         * @param endToken {Number} current largest endToken, or -1 for none\n         * @param node {AST Node}\n         */\n        function maxEndToken(endToken, node) {\n          var index;\n          if (node.endToken !== undefined) {\n            index = node.endToken;\n          } else if (node.startToken !== undefined) {\n            index = node.startToken;\n          } else {\n            return endToken;\n          }\n          if (endToken > index) {\n            return endToken;\n          }\n          return index;\n        }\n\n        // No startToken?  Then it was not parsed, pretty print it\n        if (node.startToken === undefined) {\n          pretty(node);\n          return;\n        }\n\n        switch (node.type) {\n          case \"object\":\n            // If it's not the correct type, then pretty print\n            if (!qx.tool.utils.json.Stringify.isPlainObject(object)) {\n              prettyPojo(object);\n              return;\n            }\n\n            // Create lookups\n            var childAstLookup = {};\n            node.children.forEach(function (child, index) {\n              childAstLookup[child.key.value] = child;\n            });\n            var childPropertyLookup = {};\n            for (var name in object) {\n              childPropertyLookup[name] = object[name];\n            }\n\n            // Opening brace\n            writeTokensUntil(node.startToken + 1);\n\n            // Output known children first\n            var endToken = -1;\n            var first = true;\n            for (var i = 0; i < node.children.length; i++) {\n              var child = node.children[i];\n              var key = child.key.value;\n              var value = object[key];\n\n              // Deleted a child?\n              if (value === undefined) {\n                writeTokensUntil(child.key.startToken);\n                startTokenIndex = child.value.endToken + 1;\n                if (first && i < node.children.length - 1) {\n                  while (\n                    tokenizer.tokens[startTokenIndex].type !=\n                    qx.tool.utils.json.Tokenizer.tokenTypes.COMMA\n                  ) {\n                    startTokenIndex++;\n                  }\n                  startTokenIndex++;\n                }\n                continue;\n              }\n\n              first = false;\n              endToken = maxEndToken(endToken, child.value);\n\n              // Write existing property\n              writeTokensUntil(child.value.startToken);\n              writeNode(value, child.value);\n              delete childPropertyLookup[key];\n            }\n\n            // Added properties\n            var first = node.children.length === 0;\n            var oldIndent = writer.matchIndent();\n            for (var name in childPropertyLookup) {\n              if (!first) {\n                writer.write(\",\\n\");\n                first = false;\n              }\n              prettyPojoProperty(name, childPropertyLookup[name]);\n            }\n\n            // Unindent and output the closing brace\n            writer.resetIndent(oldIndent);\n            if (endToken === -1) {\n              startTokenIndex = node.endToken;\n            } else {\n              startTokenIndex = endToken + 1;\n            }\n            writeTokensUntil(node.endToken + 1);\n            break;\n\n          case \"array\":\n            if (!qx.lang.Type.isArray(object)) {\n              prettyPojo(object);\n              return;\n            }\n\n            // Opening brace\n            writeTokensUntil(node.startToken + 1);\n\n            for (var i = 0; i < object.length; i++) {\n              var child =\n                i < node.children.length ? node.children[i] : undefined;\n              if (child !== undefined) {\n                writeTokensUntil(child.startToken);\n                writeNode(object[i], child);\n                startTokenIndex = child.endToken + 1;\n              } else {\n                var oldIndent = writer.matchIndent();\n                if (i != 0) {\n                  writer.write(\",\\n\");\n                }\n                prettyPojo(object[i]);\n                writer.resetIndent(oldIndent);\n                //startTokenIndex = node.endToken;\n              }\n            }\n\n            // Closing brace\n            writeTokensUntil(node.endToken + 1);\n            break;\n\n          case \"property\":\n            break;\n\n          case \"literal\":\n            // Check type\n            if (!qx.tool.utils.json.Stringify.isLiteral(object)) {\n              prettyPojo(object);\n              startTokenIndex = node.endToken + 1;\n              return;\n            }\n\n            // If it has not changed, then use the AST\n            if (qx.tool.utils.json.Stringify.isSameLiteral(node, object)) {\n              writeTokensUntil(node.startToken + 1);\n\n              // New value, but try and preserve prefix comment & whitespace\n            } else {\n              writeTokensUntil(node.startToken);\n              if (typeof object === \"string\") {\n                writer.write('\"' + object + '\"');\n              } else {\n                writer.write(object);\n              }\n              startTokenIndex = node.startToken + 1;\n            }\n            break;\n\n          default:\n            throw new Error(\"Unexpected node type '\" + node.type + \"'\");\n        }\n      }\n\n      // Go\n      writeNode(object, ast);\n\n      // Append any whitespace or comments which trail the JSON\n      if (startTokenIndex > -1) {\n        while (startTokenIndex < tokenizer.tokens.length) {\n          var token = tokenizer.tokens[startTokenIndex++];\n          if (\n            token.type != qx.tool.utils.json.Tokenizer.tokenTypes.COMMENT &&\n            token.type != qx.tool.utils.json.Tokenizer.tokenTypes.WHITESPACE\n          ) {\n            break;\n          }\n          writer.write(token.rawValue || token.value);\n        }\n      }\n\n      return writer.buffer;\n    },\n\n    /**\n     * Converts an AST into an ordinary POJO\n     */\n    astToObject(ast, settings) {\n      function writeNode(node) {\n        var result;\n\n        switch (node.type) {\n          case \"object\":\n            result = {};\n            node.children.forEach(function (child, index) {\n              result[child.key.value] = writeNode(child.value);\n            });\n            break;\n\n          case \"array\":\n            result = [];\n            node.children.forEach(function (child, index) {\n              result.push(writeNode(child));\n            });\n            break;\n\n          case \"literal\":\n            result = node.value;\n            break;\n\n          default:\n            throw new Error(\"Unexpected node type '\" + node.type + \"'\");\n        }\n\n        return result;\n      }\n\n      return writeNode(ast);\n    },\n\n    /**\n     * Detects whether the value is a native object\n     *\n     * @param obj {Object}\n     * @returns boolean\n     */\n    isPlainObject(obj) {\n      if (typeof obj === \"object\" && obj !== null) {\n        var proto = Object.getPrototypeOf(obj);\n        return proto === Object.prototype || proto === null;\n      }\n\n      return false;\n    },\n\n    /**\n     * Detects whether the value is a literal value\n     *\n     * @param obj {Object}\n     * @returns boolean\n     */\n    isLiteral(obj) {\n      if (\n        obj === null ||\n        typeof obj === \"string\" ||\n        typeof obj === \"number\" ||\n        typeof obj === \"boolean\"\n      ) {\n        return true;\n      }\n      return false;\n    },\n\n    /**\n     * Compares a node to see if it is the same as a literal value\n     */\n    isSameLiteral(node, object) {\n      if (node.rawValue === null && object === null) {\n        return true;\n      }\n      if (\n        (node.rawValue !== null && object === null) ||\n        (node.rawValue === null && object !== null)\n      ) {\n        return false;\n      }\n      if (typeof node.value !== typeof object) {\n        return false;\n      }\n      if (typeof node.value === \"string\") {\n        return node.value === object;\n      }\n      return node.rawValue == object;\n    }\n  }\n});\n"
  ]
}