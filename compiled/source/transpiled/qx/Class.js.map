{
  "version": 3,
  "sources": [
    "C:/Users/klein/AppData/Roaming/npm/node_modules/@qooxdoo/framework/source/class/qx/Class.js"
  ],
  "names": [
    "qx",
    "Bootstrap",
    "executePendingDefers",
    "$$dbClassInfo",
    "define",
    "statics",
    "__Property",
    "core",
    "Property",
    "name",
    "config",
    "__defineImpl",
    "ex",
    "Class",
    "$$brokenClassDefinitions",
    "include",
    "getClass",
    "implement",
    "implicitType",
    "hasOwnProperty",
    "type",
    "__validateConfig",
    "message",
    "clazz",
    "__createClass",
    "extend",
    "construct",
    "destruct",
    "forEach",
    "id",
    "__attachAnno",
    "properties",
    "__addProperties",
    "members",
    "__addMembers",
    "events",
    "__addEvents",
    "i",
    "l",
    "length",
    "__addMixin",
    "Error",
    "environment",
    "key",
    "Environment",
    "add",
    "__addInterface",
    "__validateAbstractInterfaces",
    "defer",
    "self",
    "addPendingDefer",
    "getByName",
    "classname",
    "prototype",
    "undefine",
    "$$registry",
    "ns",
    "split",
    "objects",
    "window",
    "push",
    "last",
    "parent",
    "isFunction",
    "objectGetLength",
    "isDefined",
    "util",
    "OOUtil",
    "classIsDefined",
    "getTotalNumber",
    "mixin",
    "Mixin",
    "isCompatible",
    "patch",
    "isClass",
    "obj",
    "$$type",
    "constructor",
    "isSubClassOf",
    "superClass",
    "getPropertyDefinition",
    "getProperties",
    "list",
    "$$properties",
    "apply",
    "Object",
    "keys",
    "superclass",
    "getByProperty",
    "hasProperty",
    "getEventType",
    "supportsEvent",
    "hasOwnMixin",
    "$$includes",
    "indexOf",
    "getByMixin",
    "$$flatIncludes",
    "getMixins",
    "hasMixin",
    "hasOwnInterface",
    "iface",
    "$$implements",
    "getByInterface",
    "getInterfaces",
    "$$flatImplements",
    "hasInterface",
    "implementsInterface",
    "Interface",
    "objectImplements",
    "classImplements",
    "getInstance",
    "$$instance",
    "$$allowconstruct",
    "getSubclasses",
    "subclasses",
    "registry",
    "genericToString",
    "__allowedKeys",
    "select",
    "__staticAllowedKeys",
    "allowed",
    "maps",
    "undefined",
    "$$hash",
    "isObject",
    "a",
    "checkCompatibility",
    "substr",
    "settings",
    "variants",
    "$$classtype",
    "interfaces",
    "assert",
    "group",
    "anno",
    "$$annotations",
    "lang",
    "Type",
    "isArray",
    "mixins",
    "isStrictMode",
    "setDisplayNames",
    "__createDefaultConstructor",
    "__wrapConstructor",
    "setDisplayName",
    "staticValue",
    "charAt",
    "substring",
    "basename",
    "createNamespace",
    "toString",
    "extendClass",
    "$$destructor",
    "$$events",
    "isQxCoreObject",
    "proto",
    "__validateProperty",
    "refine",
    "init",
    "event",
    "async",
    "inheritable",
    "$$inheritable",
    "$$refreshInheritables",
    "attachRefreshInheritables",
    "attachMethods",
    "has",
    "existingProperty",
    "warn",
    "$$allowedGroupKeys",
    "$$allowedKeys",
    "transform",
    "check",
    "isString",
    "base",
    "wrap",
    "member",
    "annoKey",
    "$$install",
    "Function",
    "create",
    "always",
    "flatten",
    "entry",
    "$$members",
    "defaultConstructor",
    "arguments",
    "wrapper",
    "retval",
    "$$original",
    "$$constructor",
    "$$initialized"
  ],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAAA,EAAAA,EAAE,CAACC,SAAH,CAAaC,oBAAb,CAAkCC,aAAlC;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAH,EAAAA,EAAE,CAACC,SAAH,CAAaG,MAAb,CAAoB,UAApB,EAAgC;AAC9BC,IAAAA,OAAO,EAAE;AACP;AACJ;AACA;AACA;AACIC,MAAAA,iBAAU,EAAE,OACRN,EAAE,CAACO,IAAH,CAAQC,QADA,GAER,IAPG;;AASP;AACJ;AACA;AACA;AACA;;AAEI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACIJ,MAAAA,MAnFO,kBAmFAK,IAnFA,EAmFMC,MAnFN,EAmFc;AACnB,YAAI;AACF,iBAAO,KAAKC,mBAAL,CAAkBF,IAAlB,EAAwBC,MAAxB,CAAP;AACD,SAFD,CAEE,OAAOE,EAAP,EAAW;AACXZ,UAAAA,EAAE,CAACa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",
  "sourcesContent": [
    "/* ************************************************************************\n\n   qooxdoo - the new era of web development\n\n   http://qooxdoo.org\n\n   Copyright:\n     2004-2008 1&1 Internet AG, Germany, http://www.1und1.de\n\n   License:\n     MIT: https://opensource.org/licenses/MIT\n     See the LICENSE file in the project's top-level directory for details.\n\n   Authors:\n     * Sebastian Werner (wpbasti)\n     * Andreas Ecker (ecker)\n     * John Spackman (john.spackman@zenesis.com)\n\n************************************************************************ */\n\n/**\n * This class is one of the most important parts of qooxdoo's\n * object-oriented features.\n *\n * Its {@link #define} method is used to create qooxdoo classes.\n *\n * Each instance of a class defined by {@link #define} has\n * the following keys attached to the constructor and the prototype:\n *\n * <table>\n * <tr><th><code>classname</code></th><td>The fully-qualified name of the class (e.g. <code>\"qx.ui.core.Widget\"</code>).</td></tr>\n * <tr><th><code>basename</code></th><td>The namespace part of the class name (e.g. <code>\"qx.ui.core\"</code>).</td></tr>\n * <tr><th><code>constructor</code></th><td>A reference to the constructor of the class.</td></tr>\n * <tr><th><code>superclass</code></th><td>A reference to the constructor of the super class.</td></tr>\n * </table>\n *\n * Each method may access static members of the same class by using\n * <code>this.self(arguments)</code> ({@link qx.core.Object#self}):\n * <pre class='javascript'>\n * statics : { FOO : \"bar\" },\n * members: {\n *   baz: function(x) {\n *     this.self(arguments).FOO;\n *     ...\n *   }\n * }\n * </pre>\n *\n * Each overriding method may call the overridden method by using\n * <code>this.base(arguments [, ...])</code> ({@link qx.core.Object#base}). This is also true for calling\n * the constructor of the superclass.\n * <pre class='javascript'>\n * members: {\n *   foo: function(x) {\n *     this.base(arguments, x);\n *     ...\n *   }\n * }\n * </pre>\n *\n * By using <code>qx.Class</code> within an app, the native JS data types are\n * conveniently polyfilled according to {@link qx.lang.normalize}.\n *\n * Annotations can be added to classes, constructors, destructors, and methods, properties, and statics -\n * see <code>qx.Annotation</code> for examples and means access annotations at runtime.\n *\n * @require(qx.Interface)\n * @require(qx.Mixin)\n * @require(qx.lang.normalize.Array)\n * @require(qx.lang.normalize.Date)\n * @require(qx.lang.normalize.Error)\n * @require(qx.lang.normalize.Function)\n * @require(qx.lang.normalize.String)\n * @require(qx.lang.normalize.Object)\n * @require(qx.lang.normalize.Number)\n */\nqx.Bootstrap.define(\"qx.Class\", {\n  statics: {\n    /**\n     * A static reference to the property implementation in the case it\n     * should be included.\n     */\n    __Property: qx.core.Environment.get(\"module.property\")\n      ? qx.core.Property\n      : null,\n\n    /*\n    ---------------------------------------------------------------------------\n       PUBLIC METHODS\n    ---------------------------------------------------------------------------\n    */\n\n    /**\n     * Define a new class using the qooxdoo class system. This sets up the\n     * namespace for the class and generates the class from the definition map.\n     *\n     * Example:\n     * <pre class='javascript'>\n     * qx.Class.define(\"name\",\n     * {\n     *   extend : Object, // superclass\n     *   implement : [Interfaces],\n     *   include : [Mixins],\n     *\n     *   statics:\n     *   {\n     *     CONSTANT : 3.141,\n     *\n     *     publicMethod: function() {},\n     *     _protectedMethod: function() {},\n     *     __privateMethod: function() {}\n     *   },\n     *\n     *   properties:\n     *   {\n     *     \"tabIndex\": { check: \"Number\", init : -1 }\n     *   },\n     *\n     *   members:\n     *   {\n     *     publicField: \"foo\",\n     *     publicMethod: function() {},\n     *\n     *     _protectedField: \"bar\",\n     *     _protectedMethod: function() {},\n     *\n     *     __privateField: \"baz\",\n     *     __privateMethod: function() {}\n     *   }\n     * });\n     * </pre>\n     *\n     * @param name {String?null} Name of the class. If <code>null</code>, the class\n     *   will not be added to any namespace which could be handy for testing.\n     * @param config {Map ? null} Class definition structure. The configuration map has the following keys:\n     *     <table>\n     *       <tr><th>Name</th><th>Type</th><th>Description</th></tr>\n     *       <tr><th>type</th><td>String</td><td>\n     *           Type of the class. Valid types are \"abstract\", \"static\" and \"singleton\".\n     *           If unset it defaults to a regular non-static class.\n     *       </td></tr>\n     *       <tr><th>extend</th><td>Class</td><td>The super class the current class inherits from.</td></tr>\n     *       <tr><th>implement</th><td>Interface | Interface[]</td><td>Single interface or array of interfaces the class implements.</td></tr>\n     *       <tr><th>include</th><td>Mixin | Mixin[]</td><td>Single mixin or array of mixins, which will be merged into the class.</td></tr>\n     *       <tr><th>construct</th><td>Function</td><td>The constructor of the class.</td></tr>\n     *       <tr><th>statics</th><td>Map</td><td>Map of static members of the class.</td></tr>\n     *       <tr><th>properties</th><td>Map</td><td>Map of property definitions. For a description of the format of a property definition see\n     *           {@link qx.core.Property}.</td></tr>\n     *       <tr><th>members</th><td>Map</td><td>Map of instance members of the class.</td></tr>\n     *       <tr><th>environment</th><td>Map</td><td>Map of environment settings for this class. For a description of the format of a setting see\n     *           {@link qx.core.Environment}.</td></tr>\n     *       <tr><th>events</th><td>Map</td><td>\n     *           Map of events the class fires. The keys are the names of the events and the values are the\n     *           corresponding event type class names.\n     *       </td></tr>\n     *       <tr><th>defer</th><td>Function</td><td>Function that is called at the end of processing the class declaration. It allows access to the declared statics, members and properties.</td></tr>\n     *       <tr><th>destruct</th><td>Function</td><td>The destructor of the class.</td></tr>\n     *     </table>\n     * @return {Class} The defined class\n     */\n    define(name, config) {\n      try {\n        return this.__defineImpl(name, config);\n      } catch (ex) {\n        qx.Class.$$brokenClassDefinitions = true;\n        throw ex;\n      }\n    },\n\n    /**\n     * Implementation behind `define` - this exists just for the simplicity of wrapping an exception\n     * handler around the code\n     *\n     * @param {String} name @see `define()`\n     * @param {*} config @see `define()`\n     * @returns  @see `define()`\n     */\n    __defineImpl(name, config) {\n      if (!config) {\n        config = {};\n      }\n\n      // Normalize include to array\n      if (\n        config.include &&\n        !(qx.Bootstrap.getClass(config.include) === \"Array\")\n      ) {\n        config.include = [config.include];\n      }\n\n      // Normalize implement to array\n      if (\n        config.implement &&\n        !(qx.Bootstrap.getClass(config.implement) === \"Array\")\n      ) {\n        config.implement = [config.implement];\n      }\n\n      // Normalize type\n      var implicitType = false;\n      if (!config.hasOwnProperty(\"extend\") && !config.type) {\n        config.type = \"static\";\n        implicitType = true;\n      }\n\n      // Validate incoming data\n      if (qx.core.Environment.get(\"qx.debug\")) {\n        try {\n          this.__validateConfig(name, config);\n        } catch (ex) {\n          if (implicitType) {\n            ex.message =\n              'Assumed static class because no \"extend\" key was found. ' +\n              ex.message;\n          }\n          throw ex;\n        }\n      }\n\n      // Create the class\n      var clazz = this.__createClass(\n        name,\n        config.type,\n        config.extend,\n        config.statics,\n        config.construct,\n        config.destruct,\n        config.include\n      );\n\n      // Initialise class and constructor/destructor annotations\n      [\"@\", \"@construct\", \"@destruct\"].forEach(function (id) {\n        this.__attachAnno(clazz, id, null, config[id]);\n      }, this);\n\n      // Members, properties, events and mixins are only allowed for non-static classes\n      if (config.extend) {\n        // Attach properties\n        if (config.properties) {\n          this.__addProperties(clazz, config.properties, true);\n        }\n\n        // Attach members\n        if (config.members) {\n          this.__addMembers(clazz, config.members, true, true, false);\n        }\n\n        // Process events\n        if (config.events) {\n          this.__addEvents(clazz, config.events, true);\n        }\n\n        // Include mixins\n        // Must be the last here to detect conflicts\n        if (config.include) {\n          for (var i = 0, l = config.include.length; i < l; i++) {\n            this.__addMixin(clazz, config.include[i], false);\n          }\n        }\n      }\n      // If config has a 'extend' key but it's null or undefined\n      else if (\n        config.hasOwnProperty(\"extend\") &&\n        qx.core.Environment.get(\"qx.debug\")\n      ) {\n        throw new Error('\"extend\" parameter is null or undefined');\n      }\n\n      // Process environment\n      if (config.environment) {\n        for (var key in config.environment) {\n          qx.core.Environment.add(key, config.environment[key]);\n        }\n      }\n\n      // Interface support for non-static classes\n      if (config.implement) {\n        for (var i = 0, l = config.implement.length; i < l; i++) {\n          this.__addInterface(clazz, config.implement[i]);\n        }\n      }\n\n      if (qx.core.Environment.get(\"qx.debug\")) {\n        this.__validateAbstractInterfaces(clazz);\n      }\n\n      // Process defer\n      if (config.defer) {\n        config.defer.self = clazz;\n        qx.Bootstrap.addPendingDefer(clazz, function () {\n          clazz = qx.Class.getByName(clazz.classname);\n          config.defer(clazz, clazz.prototype, {\n            add(name, config) {\n              // build pseudo properties map\n              var properties = {};\n              properties[name] = config;\n\n              // execute generic property handler\n              qx.Class.__addProperties(clazz, properties, true);\n            }\n          });\n        });\n      }\n\n      return clazz;\n    },\n\n    /**\n     * Removes a class from qooxdoo defined by {@link #define}\n     *\n     * @param name {String} Name of the class\n     */\n    undefine(name) {\n      // first, delete the class from the registry\n      delete this.$$registry[name];\n      // delete the class reference from the namespaces and all empty namespaces\n      var ns = name.split(\".\");\n      // build up an array containing all namespace objects including window\n      var objects = [window];\n      for (var i = 0; i < ns.length; i++) {\n        objects.push(objects[i][ns[i]]);\n      }\n\n      // go through all objects and check for the constructor or empty namespaces\n      for (var i = objects.length - 1; i >= 1; i--) {\n        var last = objects[i];\n        var parent = objects[i - 1];\n        if (\n          // The class being undefined, but parent classes in case it is a nested class that is being undefined\n          (i == objects.length - 1 && qx.Bootstrap.isFunction(last)) ||\n          qx.Bootstrap.objectGetLength(last) === 0\n        ) {\n          delete parent[ns[i - 1]];\n        } else {\n          break;\n        }\n      }\n    },\n\n    /**\n     * Whether the given class exists\n     *\n     * @signature function(name)\n     * @param name {String} class name to check\n     * @return {Boolean} true if class exists\n     */\n    isDefined: qx.util.OOUtil.classIsDefined,\n\n    /**\n     * Determine the total number of classes\n     *\n     * @return {Number} the total number of classes\n     */\n    getTotalNumber() {\n      return qx.Bootstrap.objectGetLength(this.$$registry);\n    },\n\n    /**\n     * Find a class by its name\n     *\n     * @signature function(name)\n     * @param name {String} class name to resolve\n     * @return {Class} the class\n     */\n    getByName: qx.Bootstrap.getByName,\n\n    /**\n     * Include all features of the given mixin into the class. The mixin must\n     * not include any methods or properties that are already available in the\n     * class. This would only be possible using the {@link #patch} method.\n     *\n     * @param clazz {Class} An existing class which should be augmented by including a mixin.\n     * @param mixin {Mixin} The mixin to be included.\n     */\n    include(clazz, mixin) {\n      if (qx.core.Environment.get(\"qx.debug\")) {\n        if (!mixin) {\n          throw new Error(\n            \"The mixin to include into class '\" +\n              clazz.classname +\n              \"' is undefined/null!\"\n          );\n        }\n\n        qx.Mixin.isCompatible(mixin, clazz);\n      }\n\n      qx.Class.__addMixin(clazz, mixin, false);\n    },\n\n    /**\n     * Include all features of the given mixin into the class. The mixin may\n     * include features, which are already defined in the target class. Existing\n     * features of equal name will be overwritten.\n     * Please keep in mind that this functionality is not intended for regular\n     * use, but as a formalized way (and a last resort) in order to patch\n     * existing classes.\n     *\n     * <b>WARNING</b>: You may break working classes and features.\n     *\n     * @param clazz {Class} An existing class which should be modified by including a mixin.\n     * @param mixin {Mixin} The mixin to be included.\n     * @return {Class} the new class definition\n     */\n    patch(clazz, mixin) {\n      if (qx.core.Environment.get(\"qx.debug\")) {\n        if (!mixin) {\n          throw new Error(\n            \"The mixin to patch class '\" +\n              clazz.classname +\n              \"' is undefined/null!\"\n          );\n        }\n\n        qx.Mixin.isCompatible(mixin, clazz);\n      }\n\n      qx.Class.__addMixin(clazz, mixin, true);\n      return qx.Class.getByName(clazz.classname);\n    },\n\n    /**\n     * Detects whether the object is a Class (and not an instance of a class)\n     *\n     *  @param obj {Object?} the object to inspect\n     *  @return {Boolean} true if it is a class, false if it is anything else\n     */\n    isClass(obj) {\n      return obj && obj.$$type === \"Class\" && obj.constructor === obj;\n    },\n\n    /**\n     * Whether a class is a direct or indirect sub class of another class,\n     * or both classes coincide.\n     *\n     * @param clazz {Class} the class to check.\n     * @param superClass {Class} the potential super class\n     * @return {Boolean} whether clazz is a sub class of superClass.\n     */\n    isSubClassOf(clazz, superClass) {\n      if (!clazz) {\n        return false;\n      }\n\n      if (clazz == superClass) {\n        return true;\n      }\n\n      if (clazz.prototype instanceof superClass) {\n        return true;\n      }\n\n      return false;\n    },\n\n    /**\n     * Returns the definition of the given property. Returns null\n     * if the property does not exist.\n     *\n     * @signature function(clazz, name)\n     * @param clazz {Class} class to check\n     * @param name {String} name of the class to check for\n     * @return {Map|null} whether the object support the given event.\n     */\n    getPropertyDefinition: qx.util.OOUtil.getPropertyDefinition,\n\n    /**\n     * Returns a list of all properties supported by the given class\n     *\n     * @param clazz {Class} Class to query\n     * @return {String[]} List of all property names\n     */\n    getProperties(clazz) {\n      var list = [];\n\n      while (clazz) {\n        if (clazz.$$properties) {\n          list.push.apply(list, Object.keys(clazz.$$properties));\n        }\n\n        clazz = clazz.superclass;\n      }\n\n      return list;\n    },\n\n    /**\n     * Returns the class or one of its superclasses which contains the\n     * declaration for the given property in its class definition. Returns null\n     * if the property is not specified anywhere.\n     *\n     * @param clazz {Class} class to look for the property\n     * @param name {String} name of the property\n     * @return {Class | null} The class which includes the property\n     */\n    getByProperty(clazz, name) {\n      while (clazz) {\n        if (clazz.$$properties && clazz.$$properties[name]) {\n          return clazz;\n        }\n\n        clazz = clazz.superclass;\n      }\n\n      return null;\n    },\n\n    /**\n     * Whether a class has the given property\n     *\n     * @signature function(clazz, name)\n     * @param clazz {Class} class to check\n     * @param name {String} name of the property to check for\n     * @return {Boolean} whether the class includes the given property.\n     */\n    hasProperty: qx.util.OOUtil.hasProperty,\n\n    /**\n     * Returns the event type of the given event. Returns null if\n     * the event does not exist.\n     *\n     * @signature function(clazz, name)\n     * @param clazz {Class} class to check\n     * @param name {String} name of the event\n     * @return {String|null} Event type of the given event.\n     */\n    getEventType: qx.util.OOUtil.getEventType,\n\n    /**\n     * Whether a class supports the given event type\n     *\n     * @signature function(clazz, name)\n     * @param clazz {Class} class to check\n     * @param name {String} name of the event to check for\n     * @return {Boolean} whether the class supports the given event.\n     */\n    supportsEvent: qx.util.OOUtil.supportsEvent,\n\n    /**\n     * Whether a class directly includes a mixin.\n     *\n     * @param clazz {Class} class to check\n     * @param mixin {Mixin} the mixin to check for\n     * @return {Boolean} whether the class includes the mixin directly.\n     */\n    hasOwnMixin(clazz, mixin) {\n      return clazz.$$includes && clazz.$$includes.indexOf(mixin) !== -1;\n    },\n\n    /**\n     * Returns the class or one of its superclasses which contains the\n     * declaration for the given mixin. Returns null if the mixin is not\n     * specified anywhere.\n     *\n     * @param clazz {Class} class to look for the mixin\n     * @param mixin {Mixin} mixin to look for\n     * @return {Class | null} The class which directly includes the given mixin\n     */\n    getByMixin(clazz, mixin) {\n      var list, i, l;\n\n      while (clazz) {\n        if (clazz.$$includes) {\n          list = clazz.$$flatIncludes;\n\n          for (i = 0, l = list.length; i < l; i++) {\n            if (list[i] === mixin) {\n              return clazz;\n            }\n          }\n        }\n\n        clazz = clazz.superclass;\n      }\n\n      return null;\n    },\n\n    /**\n     * Returns a list of all mixins available in a given class.\n     *\n     * @signature function(clazz)\n     * @param clazz {Class} class which should be inspected\n     * @return {Mixin[]} array of mixins this class uses\n     */\n    getMixins: qx.util.OOUtil.getMixins,\n\n    /**\n     * Whether a given class or any of its superclasses includes a given mixin.\n     *\n     * @param clazz {Class} class to check\n     * @param mixin {Mixin} the mixin to check for\n     * @return {Boolean} whether the class includes the mixin.\n     */\n    hasMixin(clazz, mixin) {\n      return !!this.getByMixin(clazz, mixin);\n    },\n\n    /**\n     * Whether a given class directly includes an interface.\n     *\n     * This function will only return \"true\" if the interface was defined\n     * in the class declaration ({@link qx.Class#define}) using the \"implement\"\n     * key.\n     *\n     * @param clazz {Class} class or instance to check\n     * @param iface {Interface} the interface to check for\n     * @return {Boolean} whether the class includes the mixin directly.\n     */\n    hasOwnInterface(clazz, iface) {\n      return clazz.$$implements && clazz.$$implements.indexOf(iface) !== -1;\n    },\n\n    /**\n     * Returns the class or one of its super classes which contains the\n     * declaration of the given interface. Returns null if the interface is not\n     * specified anywhere.\n     *\n     * @signature function(clazz, iface)\n     * @param clazz {Class} class to look for the interface\n     * @param iface {Interface} interface to look for\n     * @return {Class | null} the class which directly implements the given interface\n     */\n    getByInterface: qx.util.OOUtil.getByInterface,\n\n    /**\n     * Returns a list of all interfaces a given class has to implement.\n     *\n     * @param clazz {Class} class which should be inspected\n     * @return {Interface[]} array of interfaces this class implements\n     */\n    getInterfaces(clazz) {\n      var list = [];\n\n      while (clazz) {\n        if (clazz.$$implements) {\n          list.push.apply(list, clazz.$$flatImplements);\n        }\n\n        clazz = clazz.superclass;\n      }\n\n      return list;\n    },\n\n    /**\n     * Whether a given class or any of its super classes includes a given interface.\n     *\n     * This function will return \"true\" if the interface was defined\n     * in the class declaration ({@link qx.Class#define}) of the class\n     * or any of its super classes using the \"implement\"\n     * key.\n     *\n     * @signature function(clazz, iface)\n     * @param clazz {Class} class to check\n     * @param iface {Interface} the interface to check for\n     * @return {Boolean} whether the class includes the interface.\n     */\n    hasInterface: qx.util.OOUtil.hasInterface,\n\n    /**\n     * Whether a given class complies to an interface.\n     *\n     * Checks whether all methods defined in the interface are\n     * implemented. The class does not need to implement\n     * the interface explicitly in the <code>extend</code> key.\n     *\n     * @param obj {Object} class to check\n     * @param iface {Interface} the interface to check for\n     * @return {Boolean} whether the class conforms to the interface.\n     */\n    implementsInterface(obj, iface) {\n      var clazz = obj.constructor;\n\n      if (this.hasInterface(clazz, iface)) {\n        return true;\n      }\n\n      if (qx.Interface.objectImplements(obj, iface)) {\n        return true;\n      }\n\n      if (qx.Interface.classImplements(clazz, iface)) {\n        return true;\n      }\n\n      return false;\n    },\n\n    /**\n     * Helper method to handle singletons\n     *\n     * @internal\n     * @return {Object} The singleton instance\n     */\n    getInstance() {\n      if (this.$$instance === null) {\n        throw new Error(\n          \"Singleton instance of \" +\n            this +\n            \" is requested, but not ready yet. This is most likely due to a recursive call in the constructor path.\"\n        );\n      }\n\n      if (!this.$$instance) {\n        this.$$allowconstruct = true;\n        this.$$instance = null; // null means \"object is being created\"; needed for another call of getInstance() during instantiation\n        this.$$instance = new this();\n        delete this.$$allowconstruct;\n      }\n\n      return this.$$instance;\n    },\n\n    /**\n     * Retreive all subclasses of a given class\n     *\n     * @param clazz {Class} the class which should be inspected\n     *\n     * @return {Object} class name hash holding the references to the subclasses or null if the class does not exist.\n     */\n    getSubclasses(clazz) {\n      if (!clazz) {\n        return null;\n      }\n\n      var subclasses = {};\n      var registry = qx.Class.$$registry;\n\n      for (var name in registry) {\n        if (registry[name].superclass && registry[name].superclass == clazz) {\n          subclasses[name] = registry[name];\n        }\n      }\n\n      return subclasses;\n    },\n\n    /*\n    ---------------------------------------------------------------------------\n       PRIVATE/INTERNAL BASICS\n    ---------------------------------------------------------------------------\n    */\n\n    /**\n     * This method will be attached to all classes to return\n     * a nice identifier for them.\n     *\n     * @internal\n     * @return {String} The class identifier\n     */\n    genericToString() {\n      return \"[Class \" + this.classname + \"]\";\n    },\n\n    /** Stores all defined classes */\n    $$registry: qx.Bootstrap.$$registry,\n\n    /** @type {Map} allowed keys in non-static class definition */\n    __allowedKeys: qx.core.Environment.select(\"qx.debug\", {\n      true: {\n        \"@\": \"object\",\n        \"@construct\": \"object\",\n        \"@destruct\": \"object\",\n        type: \"string\", // String\n        extend: \"function\", // Function\n        implement: \"object\", // Interface[]\n        include: \"object\", // Mixin[]\n        construct: \"function\", // Function\n        statics: \"object\", // Map\n        properties: \"object\", // Map\n        members: \"object\", // Map\n        environment: \"object\", // Map\n        events: \"object\", // Map\n        defer: \"function\", // Function\n        destruct: \"function\" // Function\n      },\n\n      default: null\n    }),\n\n    /** @type {Map} allowed keys in static class definition */\n    __staticAllowedKeys: qx.core.Environment.select(\"qx.debug\", {\n      true: {\n        \"@\": \"object\",\n        type: \"string\", // String\n        statics: \"object\", // Map\n        environment: \"object\", // Map\n        defer: \"function\" // Function\n      },\n\n      default: null\n    }),\n\n    /**\n     * Validates an incoming configuration and checks for proper keys and values\n     *\n     * @signature function(name, config)\n     * @param name {String} The name of the class\n     * @param config {Map} Configuration map\n     */\n    __validateConfig: qx.core.Environment.select(\"qx.debug\", {\n      true(name, config) {\n        // Validate type\n        if (\n          config.type &&\n          !(\n            config.type === \"static\" ||\n            config.type === \"abstract\" ||\n            config.type === \"singleton\"\n          )\n        ) {\n          throw new Error(\n            'Invalid type \"' +\n              config.type +\n              '\" definition for class \"' +\n              name +\n              '\"!'\n          );\n        }\n\n        // Validate non-static class on the \"extend\" key\n        if (config.type && config.type !== \"static\" && !config.extend) {\n          throw new Error(\n            'Invalid config in class \"' +\n              name +\n              '\"! Every non-static class has to extend at least the \"qx.core.Object\" class.'\n          );\n        }\n\n        // Validate keys\n        var allowed =\n          config.type === \"static\"\n            ? this.__staticAllowedKeys\n            : this.__allowedKeys;\n        for (var key in config) {\n          if (!allowed[key]) {\n            throw new Error(\n              'The configuration key \"' +\n                key +\n                '\" in class \"' +\n                name +\n                '\" is not allowed!'\n            );\n          }\n\n          if (config[key] == null) {\n            throw new Error(\n              'Invalid key \"' +\n                key +\n                '\" in class \"' +\n                name +\n                '\"! The value is undefined/null!'\n            );\n          }\n\n          if (typeof config[key] !== allowed[key]) {\n            throw new Error(\n              'Invalid type of key \"' +\n                key +\n                '\" in class \"' +\n                name +\n                '\"! The type of the key must be \"' +\n                allowed[key] +\n                '\"!'\n            );\n          }\n        }\n\n        // Validate maps\n        var maps = [\n          \"statics\",\n          \"properties\",\n          \"members\",\n          \"environment\",\n          \"settings\",\n          \"variants\",\n          \"events\"\n        ];\n\n        for (var i = 0, l = maps.length; i < l; i++) {\n          var key = maps[i];\n\n          if (\n            config[key] !== undefined &&\n            (config[key].$$hash !== undefined ||\n              !qx.Bootstrap.isObject(config[key]))\n          ) {\n            throw new Error(\n              'Invalid key \"' +\n                key +\n                '\" in class \"' +\n                name +\n                '\"! The value needs to be a map!'\n            );\n          }\n        }\n\n        // Validate include definition\n        if (config.include) {\n          if (qx.Bootstrap.getClass(config.include) === \"Array\") {\n            for (var i = 0, a = config.include, l = a.length; i < l; i++) {\n              if (a[i] == null || a[i].$$type !== \"Mixin\") {\n                throw new Error(\n                  'The include definition in class \"' +\n                    name +\n                    '\" contains an invalid mixin at position ' +\n                    i +\n                    \": \" +\n                    a[i]\n                );\n              }\n            }\n          } else {\n            throw new Error(\n              'Invalid include definition in class \"' +\n                name +\n                '\"! Only mixins and arrays of mixins are allowed!'\n            );\n          }\n        }\n\n        // Validate implement definition\n        if (config.implement) {\n          if (qx.Bootstrap.getClass(config.implement) === \"Array\") {\n            for (var i = 0, a = config.implement, l = a.length; i < l; i++) {\n              if (a[i] == null || a[i].$$type !== \"Interface\") {\n                throw new Error(\n                  'The implement definition in class \"' +\n                    name +\n                    '\" contains an invalid interface at position ' +\n                    i +\n                    \": \" +\n                    a[i]\n                );\n              }\n            }\n          } else {\n            throw new Error(\n              'Invalid implement definition in class \"' +\n                name +\n                '\"! Only interfaces and arrays of interfaces are allowed!'\n            );\n          }\n        }\n\n        // Check mixin compatibility\n        if (config.include) {\n          try {\n            qx.Mixin.checkCompatibility(config.include);\n          } catch (ex) {\n            throw new Error(\n              'Error in include definition of class \"' +\n                name +\n                '\"! ' +\n                ex.message\n            );\n          }\n        }\n\n        // Validate environment\n        if (config.environment) {\n          for (var key in config.environment) {\n            if (\n              key.substr(0, key.indexOf(\".\")) !=\n              name.substr(0, name.indexOf(\".\"))\n            ) {\n              throw new Error(\n                'Forbidden environment setting \"' +\n                  key +\n                  '\" found in \"' +\n                  name +\n                  '\". It is forbidden to define a ' +\n                  \"environment setting for an external namespace!\"\n              );\n            }\n          }\n        }\n\n        // Validate settings\n        if (config.settings) {\n          for (var key in config.settings) {\n            if (\n              key.substr(0, key.indexOf(\".\")) !=\n              name.substr(0, name.indexOf(\".\"))\n            ) {\n              throw new Error(\n                'Forbidden setting \"' +\n                  key +\n                  '\" found in \"' +\n                  name +\n                  '\". It is forbidden to define a default setting for an external namespace!'\n              );\n            }\n          }\n        }\n\n        // Validate variants\n        if (config.variants) {\n          for (var key in config.variants) {\n            if (\n              key.substr(0, key.indexOf(\".\")) !=\n              name.substr(0, name.indexOf(\".\"))\n            ) {\n              throw new Error(\n                'Forbidden variant \"' +\n                  key +\n                  '\" found in \"' +\n                  name +\n                  '\". It is forbidden to define a variant for an external namespace!'\n              );\n            }\n          }\n        }\n      },\n\n      default(name, config) {}\n    }),\n\n    /**\n     * Validates the interfaces required by abstract base classes\n     *\n     * @signature function(clazz)\n     * @param clazz {Class} The configured class.\n     */\n    __validateAbstractInterfaces: qx.core.Environment.select(\"qx.debug\", {\n      true(clazz) {\n        var superclass = clazz.superclass;\n        while (superclass) {\n          if (superclass.$$classtype !== \"abstract\") {\n            break;\n          }\n\n          var interfaces = superclass.$$implements;\n          if (interfaces) {\n            for (var i = 0; i < interfaces.length; i++) {\n              qx.Interface.assert(clazz, interfaces[i], true);\n            }\n          }\n          superclass = superclass.superclass;\n        }\n      },\n\n      default(clazz) {}\n    }),\n\n    /**\n     * Attaches an annotation to a class\n     *\n     * @param clazz {Map} Static methods or fields\n     * @param group {String} Group name\n     * @param key {String} Name of the annotated item\n     * @param anno {Object} Annotation object\n     */\n    __attachAnno(clazz, group, key, anno) {\n      if (anno !== undefined) {\n        if (clazz.$$annotations === undefined) {\n          clazz.$$annotations = {};\n          clazz.$$annotations[group] = {};\n        } else if (clazz.$$annotations[group] === undefined) {\n          clazz.$$annotations[group] = {};\n        }\n\n        if (!qx.lang.Type.isArray(anno)) {\n          anno = [anno];\n        }\n\n        if (key) {\n          clazz.$$annotations[group][key] = anno;\n        } else {\n          clazz.$$annotations[group] = anno;\n        }\n      }\n    },\n\n    /**\n     * Creates a class by type. Supports modern inheritance etc.\n     *\n     * @param name {String} Full name of the class\n     * @param type {String} type of the class, i.e. \"static\", \"abstract\" or \"singleton\"\n     * @param extend {Class} Superclass to inherit from\n     * @param statics {Map} Static methods or fields\n     * @param construct {Function} Constructor of the class\n     * @param destruct {Function} Destructor of the class\n     * @param mixins {Mixin[]} array of mixins of the class\n     * @return {Class} The generated class\n     */\n    __createClass(name, type, extend, statics, construct, destruct, mixins) {\n      var isStrictMode = function () {\n        return typeof this == \"undefined\";\n      };\n\n      var clazz;\n\n      if (!extend && qx.core.Environment.get(\"qx.aspects\") == false) {\n        // Create empty/non-empty class\n        clazz = statics || {};\n        qx.Bootstrap.setDisplayNames(clazz, name);\n      } else {\n        clazz = {};\n\n        if (extend) {\n          // Create default constructor\n          if (!construct) {\n            construct = this.__createDefaultConstructor();\n          }\n\n          clazz = this.__wrapConstructor(construct, name, type);\n\n          // Add singleton getInstance()\n          if (type === \"singleton\") {\n            clazz.getInstance = this.getInstance;\n          }\n\n          qx.Bootstrap.setDisplayName(construct, name, \"constructor\");\n        }\n\n        // Copy statics\n        if (statics) {\n          qx.Bootstrap.setDisplayNames(statics, name);\n\n          var key;\n\n          for (var i = 0, a = Object.keys(statics), l = a.length; i < l; i++) {\n            key = a[i];\n            var staticValue = statics[key];\n\n            if (qx.core.Environment.get(\"qx.debug\")) {\n              if (key.charAt(0) === \"@\") {\n                if (statics[key.substring(1)] === undefined) {\n                  throw new Error(\n                    'Annonation for static \"' +\n                      key.substring(1) +\n                      '\" of Class \"' +\n                      clazz.classname +\n                      '\" does not exist!'\n                  );\n                }\n                if (key.charAt(1) === \"_\" && key.charAt(2) === \"_\") {\n                  throw new Error(\n                    'Cannot annotate private static \"' +\n                      key.substring(1) +\n                      '\" of Class \"' +\n                      clazz.classname\n                  );\n                }\n              }\n            }\n            if (key.charAt(0) === \"@\") {\n              continue;\n            }\n\n            if (qx.core.Environment.get(\"qx.aspects\")) {\n              if (staticValue instanceof Function) {\n                staticValue = qx.core.Aspect.wrap(\n                  name + \".\" + key,\n                  staticValue,\n                  \"static\"\n                );\n              }\n\n              clazz[key] = staticValue;\n            } else {\n              clazz[key] = staticValue;\n            }\n\n            // Attach annotations\n            this.__attachAnno(clazz, \"statics\", key, statics[\"@\" + key]);\n          }\n        }\n      }\n\n      // Create namespace\n      var basename = name ? qx.Bootstrap.createNamespace(name, clazz) : \"\";\n\n      // Store names in constructor/object\n      clazz.classname = name;\n      if (!isStrictMode()) {\n        try {\n          clazz.name = name;\n        } catch (ex) {\n          // Nothing\n        }\n      }\n      clazz.basename = basename;\n\n      // Store type info\n      clazz.$$type = \"Class\";\n      if (type) {\n        clazz.$$classtype = type;\n      }\n\n      // Attach toString\n      if (!clazz.hasOwnProperty(\"toString\")) {\n        clazz.toString = this.genericToString;\n      }\n\n      if (extend) {\n        qx.Bootstrap.extendClass(clazz, construct, extend, name, basename);\n\n        // Store destruct onto class\n        if (destruct) {\n          if (qx.core.Environment.get(\"qx.aspects\")) {\n            destruct = qx.core.Aspect.wrap(name, destruct, \"destructor\");\n          }\n\n          clazz.$$destructor = destruct;\n          qx.Bootstrap.setDisplayName(destruct, name, \"destruct\");\n        }\n      }\n\n      // Store class reference in global class registry\n      this.$$registry[name] = clazz;\n\n      // Return final class object\n      return clazz;\n    },\n\n    /*\n    ---------------------------------------------------------------------------\n       PRIVATE ADD HELPERS\n    ---------------------------------------------------------------------------\n    */\n\n    /**\n     * Attach events to the class\n     *\n     * @param clazz {Class} class to add the events to\n     * @param events {Map} map of event names the class fires.\n     * @param patch {Boolean ? false} Enable redefinition of event type?\n     */\n    __addEvents(clazz, events, patch) {\n      if (qx.core.Environment.get(\"qx.debug\")) {\n        if (\n          typeof events !== \"object\" ||\n          qx.Bootstrap.getClass(events) === \"Array\"\n        ) {\n          throw new Error(\n            clazz.classname + \": the events must be defined as map!\"\n          );\n        }\n\n        for (var key in events) {\n          if (typeof events[key] !== \"string\") {\n            throw new Error(\n              clazz.classname +\n                \"/\" +\n                key +\n                \": the event value needs to be a string with the class name of the event object which will be fired.\"\n            );\n          }\n        }\n\n        // Compare old and new event type/value if patching is disabled\n        if (clazz.$$events && patch !== true) {\n          for (var key in events) {\n            if (\n              clazz.$$events[key] !== undefined &&\n              clazz.$$events[key] !== events[key]\n            ) {\n              throw new Error(\n                clazz.classname +\n                  \"/\" +\n                  key +\n                  \": the event value/type cannot be changed from \" +\n                  clazz.$$events[key] +\n                  \" to \" +\n                  events[key]\n              );\n            }\n          }\n        }\n      }\n\n      if (clazz.$$events) {\n        for (var key in events) {\n          clazz.$$events[key] = events[key];\n        }\n      } else {\n        clazz.$$events = events;\n      }\n    },\n\n    /**\n     * Attach properties to classes\n     *\n     * @param clazz {Class} class to add the properties to\n     * @param properties {Map} map of properties\n     * @param patch {Boolean ? false} Overwrite property with the limitations of a property\n               which means you are able to refine but not to replace (esp. for new properties)\n     */\n    __addProperties(clazz, properties, patch) {\n      // check for the property module\n      if (!qx.core.Environment.get(\"module.property\")) {\n        throw new Error(\"Property module disabled.\");\n      }\n\n      if (qx.core.Environment.get(\"qx.debug\")) {\n        if (qx.Bootstrap.isQxCoreObject(properties)) {\n          throw new Error(\"Invalid 'properties' for \" + clazz.classname);\n        }\n      }\n\n      var config;\n\n      if (patch === undefined) {\n        patch = false;\n      }\n\n      var proto = clazz.prototype;\n\n      for (var name in properties) {\n        config = properties[name];\n\n        // Check incoming configuration\n        if (qx.core.Environment.get(\"qx.debug\")) {\n          this.__validateProperty(clazz, name, config, patch);\n        }\n\n        // Store name into configuration\n        config.name = name;\n\n        // Add config to local registry\n        if (!config.refine) {\n          if (clazz.$$properties === undefined) {\n            clazz.$$properties = {};\n          }\n\n          clazz.$$properties[name] = config;\n        }\n\n        // Store init value to prototype. This makes it possible to\n        // overwrite this value in derived classes.\n        if (config.init !== undefined) {\n          clazz.prototype[\"$$init_\" + name] = config.init;\n        }\n\n        // register event name\n        if (config.event !== undefined) {\n          // break if no events layer loaded\n          if (!qx.core.Environment.get(\"module.events\")) {\n            throw new Error(\"Events module not enabled.\");\n          }\n          var event = {};\n          event[config.event] = \"qx.event.type.Data\";\n          if (config.async) {\n            event[config.event + \"Async\"] = \"qx.event.type.Data\";\n          }\n          this.__addEvents(clazz, event, patch);\n        }\n\n        // Remember inheritable properties\n        if (config.inheritable) {\n          this.__Property.$$inheritable[name] = true;\n          if (!proto.$$refreshInheritables) {\n            this.__Property.attachRefreshInheritables(clazz);\n          }\n        }\n\n        if (!config.refine) {\n          this.__Property.attachMethods(clazz, name, config);\n        }\n\n        // Add annotations\n        this.__attachAnno(clazz, \"properties\", name, config[\"@\"]);\n      }\n    },\n\n    /**\n     * Validates the given property\n     *\n     * @signature function(clazz, name, config, patch)\n     * @param clazz {Class} class to add property to\n     * @param name {String} name of the property\n     * @param config {Map} configuration map\n     * @param patch {Boolean ? false} enable refine/patch?\n     */\n    __validateProperty: qx.core.Environment.select(\"qx.debug\", {\n      true(clazz, name, config, patch) {\n        // check for properties\n        if (!qx.core.Environment.get(\"module.property\")) {\n          throw new Error(\"Property module disabled.\");\n        }\n\n        var has = this.hasProperty(clazz, name);\n\n        if (has) {\n          var existingProperty = this.getPropertyDefinition(clazz, name);\n\n          if (\n            config.refine &&\n            existingProperty.init === undefined &&\n            existingProperty[\"@\"] === undefined\n          ) {\n            this.warn(\n              \"Refine a property when there is previously no init or annotations defined. Property '\" +\n                name +\n                \"' of class '\" +\n                clazz.classname +\n                \"'.\"\n            );\n          }\n        }\n\n        if (!has && config.refine) {\n          throw new Error(\n            \"Could not refine non-existent property: '\" +\n              name +\n              \"' of class: '\" +\n              clazz.classname +\n              \"'!\"\n          );\n        }\n\n        if (has && !patch) {\n          throw new Error(\n            \"Class \" +\n              clazz.classname +\n              \" already has a property: \" +\n              name +\n              \"!\"\n          );\n        }\n\n        if (has && patch) {\n          if (!config.refine) {\n            throw new Error(\n              'Could not refine property \"' +\n                name +\n                '\" without a \"refine\" flag in the property definition! This class: ' +\n                clazz.classname +\n                \", original class: \" +\n                this.getByProperty(clazz, name).classname +\n                \".\"\n            );\n          }\n\n          for (var key in config) {\n            if (key !== \"init\" && key !== \"refine\" && key !== \"@\") {\n              throw new Error(\n                \"Class \" +\n                  clazz.classname +\n                  \" could not refine property: \" +\n                  name +\n                  \"! Key: \" +\n                  key +\n                  \" could not be refined!\"\n              );\n            }\n          }\n        }\n\n        // Check 0.7 keys\n        var allowed = config.group\n          ? this.__Property.$$allowedGroupKeys\n          : this.__Property.$$allowedKeys;\n        for (var key in config) {\n          if (allowed[key] === undefined) {\n            throw new Error(\n              'The configuration key \"' +\n                key +\n                '\" of property \"' +\n                name +\n                '\" in class \"' +\n                clazz.classname +\n                '\" is not allowed!'\n            );\n          }\n\n          if (config[key] === undefined) {\n            throw new Error(\n              'Invalid key \"' +\n                key +\n                '\" of property \"' +\n                name +\n                '\" in class \"' +\n                clazz.classname +\n                '\"! The value is undefined: ' +\n                config[key]\n            );\n          }\n\n          if (allowed[key] !== null && typeof config[key] !== allowed[key]) {\n            throw new Error(\n              'Invalid type of key \"' +\n                key +\n                '\" of property \"' +\n                name +\n                '\" in class \"' +\n                clazz.classname +\n                '\"! The type of the key must be \"' +\n                allowed[key] +\n                '\"!'\n            );\n          }\n        }\n\n        if (config.transform != null) {\n          if (!(typeof config.transform === \"string\")) {\n            throw new Error(\n              'Invalid transform definition of property \"' +\n                name +\n                '\" in class \"' +\n                clazz.classname +\n                '\"! Needs to be a String.'\n            );\n          }\n        }\n\n        if (config.check != null) {\n          if (\n            !qx.Bootstrap.isString(config.check) &&\n            !qx.Bootstrap.isArray(config.check) &&\n            !qx.Bootstrap.isFunction(config.check)\n          ) {\n            throw new Error(\n              'Invalid check definition of property \"' +\n                name +\n                '\" in class \"' +\n                clazz.classname +\n                '\"! Needs to be a String, Array or Function.'\n            );\n          }\n        }\n      },\n\n      default: null\n    }),\n\n    /**\n     * Attach members to a class\n     *\n     * @param clazz {Class} clazz to add members to\n     * @param members {Map} The map of members to attach\n     * @param patch {Boolean ? false} Enable patching of\n     * @param base {Boolean ? true} Attach base flag to mark function as members\n     *     of this class\n     * @param wrap {Boolean ? false} Whether the member method should be wrapped.\n     *     this is needed to allow base calls in patched mixin members.\n     */\n    __addMembers(clazz, members, patch, base, wrap) {\n      var proto = clazz.prototype;\n      var key, member;\n      qx.Bootstrap.setDisplayNames(members, clazz.classname + \".prototype\");\n\n      for (var i = 0, a = Object.keys(members), l = a.length; i < l; i++) {\n        key = a[i];\n        member = members[key];\n\n        if (qx.core.Environment.get(\"qx.debug\")) {\n          if (key.charAt(0) === \"@\") {\n            var annoKey = key.substring(1);\n            if (\n              members[annoKey] === undefined &&\n              proto[annoKey] === undefined\n            ) {\n              throw new Error(\n                'Annonation for \"' +\n                  annoKey +\n                  '\" of Class \"' +\n                  clazz.classname +\n                  '\" does not exist!'\n              );\n            }\n            if (key.charAt(1) === \"_\" && key.charAt(2) === \"_\") {\n              throw new Error(\n                'Cannot annotate private member \"' +\n                  key.substring(1) +\n                  '\" of Class \"' +\n                  clazz.classname\n              );\n            }\n          } else {\n            if (\n              proto[key] !== undefined &&\n              key.charAt(0) === \"_\" &&\n              key.charAt(1) === \"_\"\n            ) {\n              throw new Error(\n                'Overwriting private member \"' +\n                  key +\n                  '\" of Class \"' +\n                  clazz.classname +\n                  '\" is not allowed!'\n              );\n            }\n\n            if (patch !== true && proto.hasOwnProperty(key)) {\n              throw new Error(\n                'Overwriting member \"' +\n                  key +\n                  '\" of Class \"' +\n                  clazz.classname +\n                  '\" is not allowed!'\n              );\n            }\n          }\n        }\n\n        // Annotations are not members\n        if (key.charAt(0) === \"@\") {\n          var annoKey = key.substring(1);\n          if (members[annoKey] === undefined) {\n            this.__attachAnno(clazz, \"members\", annoKey, members[key]);\n          }\n          continue;\n        }\n\n        // If it's a property accessor, we need to install it now so that this.base can refer to it\n        if (proto[key] != undefined && proto[key].$$install) {\n          proto[key].$$install();\n        }\n\n        // Added helper stuff to functions\n        // Hint: Could not use typeof function because RegExp objects are functions, too\n        // Protect to apply base property and aspect support on special attributes e.g.\n        // classes which are function like as well.\n        if (\n          base !== false &&\n          member instanceof Function &&\n          member.$$type == null\n        ) {\n          // If the class has it's own implementation, we need to remember that method in the\n          //  mixed-in method's `.base`; wrap the method with a closure so that it can have a\n          //  `.base` set, if we were to set `member.base` it would mean that the mixin can\n          //  only be added into one class\n          if (wrap) {\n            if (proto[key]) {\n              member = qx.lang.Function.create(member, { always: true });\n            }\n            member.self = clazz;\n          }\n          member.base = proto[key];\n\n          if (qx.core.Environment.get(\"qx.aspects\")) {\n            member = qx.core.Aspect.wrap(\n              clazz.classname + \".\" + key,\n              member,\n              \"member\"\n            );\n          }\n        }\n\n        // Attach member\n        proto[key] = member;\n\n        // Attach annotations\n        this.__attachAnno(clazz, \"members\", key, members[\"@\" + key]);\n      }\n    },\n\n    /**\n     * Add a single interface to a class\n     *\n     * @param clazz {Class} class to add interface to\n     * @param iface {Interface} the Interface to add\n     */\n    __addInterface(clazz, iface) {\n      if (qx.core.Environment.get(\"qx.debug\")) {\n        if (!clazz || !iface) {\n          throw new Error(\"Incomplete parameters!\");\n        }\n\n        // This differs from mixins, we only check if the interface is already\n        // directly used by this class. It is allowed however, to have an interface\n        // included multiple times by extends in the interfaces etc.\n        if (this.hasOwnInterface(clazz, iface)) {\n          throw new Error(\n            'Interface \"' +\n              iface.name +\n              '\" is already used by Class \"' +\n              clazz.classname +\n              \"!\"\n          );\n        }\n\n        // Check interface and wrap members\n        if (clazz.$$classtype !== \"abstract\") {\n          qx.Interface.assert(clazz, iface, true);\n        }\n      }\n\n      // Store interface reference\n      var list = qx.Interface.flatten([iface]);\n      if (clazz.$$implements) {\n        clazz.$$implements.push(iface);\n        clazz.$$flatImplements.push.apply(clazz.$$flatImplements, list);\n      } else {\n        clazz.$$implements = [iface];\n        clazz.$$flatImplements = list;\n      }\n    },\n\n    /**\n     * Include all features of the mixin into the given class, recursively.\n     *\n     * @param clazz {Class} The class onto which the mixin should be attached.\n     * @param mixin {Mixin} Include all features of this mixin\n     * @param patch {Boolean} Overwrite existing fields, functions and properties\n     */\n    __addMixin(clazz, mixin, patch) {\n      if (qx.core.Environment.get(\"qx.debug\")) {\n        if (!clazz || !mixin) {\n          throw new Error(\"Incomplete parameters!\");\n        }\n      }\n\n      if (this.hasMixin(clazz, mixin)) {\n        return;\n      }\n\n      // Attach content\n      var list = qx.Mixin.flatten([mixin]);\n      var entry;\n\n      for (var i = 0, l = list.length; i < l; i++) {\n        entry = list[i];\n\n        // Attach events\n        if (entry.$$events) {\n          this.__addEvents(clazz, entry.$$events, patch);\n        }\n\n        // Attach properties (Properties are already readonly themselves, no patch handling needed)\n        if (entry.$$properties) {\n          this.__addProperties(clazz, entry.$$properties, patch);\n        }\n\n        // Attach members (Respect patch setting, but dont apply base variables)\n        if (entry.$$members) {\n          this.__addMembers(clazz, entry.$$members, patch, patch, patch);\n        }\n      }\n\n      // Store mixin reference\n      if (clazz.$$includes) {\n        clazz.$$includes.push(mixin);\n        clazz.$$flatIncludes.push.apply(clazz.$$flatIncludes, list);\n      } else {\n        clazz.$$includes = [mixin];\n        clazz.$$flatIncludes = list;\n      }\n    },\n\n    /*\n    ---------------------------------------------------------------------------\n       PRIVATE FUNCTION HELPERS\n    ---------------------------------------------------------------------------\n    */\n\n    /**\n     * Returns the default constructor.\n     * This constructor just calls the constructor of the base class.\n     *\n     * @return {Function} The default constructor.\n     */\n    __createDefaultConstructor() {\n      function defaultConstructor() {\n        defaultConstructor.base.apply(this, arguments);\n      }\n\n      return defaultConstructor;\n    },\n\n    /**\n     * Generate a wrapper of the original class constructor in order to enable\n     * some of the advanced OO features (e.g. abstract class, singleton, mixins)\n     *\n     * @param construct {Function} the original constructor\n     * @param name {String} name of the class\n     * @param type {String} the user specified class type\n     * @return {Function} The wrapped constructor\n     */\n    __wrapConstructor(construct, name, type) {\n      var wrapper = function () {\n        var clazz = wrapper;\n\n        if (qx.core.Environment.get(\"qx.debug\")) {\n          // new keyword check\n          if (!(this instanceof clazz)) {\n            throw new Error(\n              \"Please initialize '\" + name + \"' objects using the new keyword!\"\n            );\n          }\n\n          // add abstract and singleton checks\n          if (type === \"abstract\") {\n            if (this.classname === name) {\n              throw new Error(\n                \"The class ',\" +\n                  name +\n                  \"' is abstract! It is not possible to instantiate it.\"\n              );\n            }\n          } else if (type === \"singleton\") {\n            if (!clazz.$$allowconstruct) {\n              throw new Error(\n                \"The class '\" +\n                  name +\n                  \"' is a singleton! It is not possible to instantiate it directly. Use the static getInstance() method instead.\"\n              );\n            }\n          }\n        }\n\n        // Execute default constructor\n        var retval = clazz.$$original.apply(this, arguments);\n\n        // Initialize local mixins\n        if (clazz.$$includes) {\n          var mixins = clazz.$$flatIncludes;\n          for (var i = 0, l = mixins.length; i < l; i++) {\n            if (mixins[i].$$constructor) {\n              mixins[i].$$constructor.apply(this, arguments);\n            }\n          }\n        }\n\n        if (qx.core.Environment.get(\"qx.debug\")) {\n          // Mark instance as initialized\n          if (this.classname === name) {\n            this.$$initialized = true;\n          }\n        }\n\n        // Return optional return value\n        return retval;\n      };\n\n      if (qx.core.Environment.get(\"qx.aspects\")) {\n        var aspectWrapper = qx.core.Aspect.wrap(name, wrapper, \"constructor\");\n        wrapper.$$original = construct;\n        wrapper.constructor = aspectWrapper;\n        wrapper = aspectWrapper;\n      }\n\n      // Store original constructor\n      wrapper.$$original = construct;\n\n      // Store wrapper into constructor (needed for base calls etc.)\n      construct.wrapper = wrapper;\n\n      // Return generated wrapper\n      return wrapper;\n    }\n  },\n\n  defer() {\n    // Binding of already loaded bootstrap classes\n    if (qx.core.Environment.get(\"qx.aspects\")) {\n      for (var classname in qx.Bootstrap.$$registry) {\n        var statics = qx.Bootstrap.$$registry[classname];\n\n        for (var key in statics) {\n          // only functions, no regexps\n          if (statics[key] instanceof Function) {\n            statics[key] = qx.core.Aspect.wrap(\n              classname + \".\" + key,\n              statics[key],\n              \"static\"\n            );\n          }\n        }\n      }\n    }\n  }\n});\n"
  ]
}